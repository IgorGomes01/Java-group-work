Index: src/main/java/org/projektarbete/AppointmentRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.projektarbete;\r\nimport java.sql.*;\r\nimport java.util.Map;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.util.Objects;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\nimport static org.projektarbete.AppointmentAgenda.askForContinue;\r\nimport static org.projektarbete.AppointmentAgenda.printReturningToMainMenu;\r\nimport static org.projektarbete.DatabaseManager.DRIVER;\r\nimport static org.projektarbete.DatabaseManager.logger;\r\n\r\n/**\r\n * Hanterar mötesinformation och interaktion med en databas.\r\n */\r\npublic class AppointmentRepository {\r\n\r\n    // Fält för databaskolumnernas namn\r\n    private static final String FIELD_NAME = \"name\";\r\n    private static final String FIELD_ID_NUMBER = \"idNumber\";\r\n    private static final String FIELD_EMAIL = \"email\";\r\n    private static final String FIELD_DATE = \"date\";\r\n    private static final String FIELD_TIME = \"time\";\r\n    private static final String FIELD_DESCRIPTION = \"Description\";\r\n\r\n    // Konstanter för JDBC URL och databasnamn\r\n    private static final String JDBC_URL = DatabaseManager.getJDBCUrl();\r\n    private static final String DATABASE_NAME = DatabaseManager.getDatabaseName();\r\n\r\n    // InputReader för användarinput\r\n    private static final InputReader inputReader = new InputReader();\r\n\r\n    // Kartläggning av engelska fältnamn till svenska visningsnamn\r\n    private static final Map<String, String> SWEDISH_FIELD_NAMES = Map.of(\r\n            FIELD_NAME, \"namn\",\r\n            FIELD_ID_NUMBER, \"personnummer\",\r\n            FIELD_EMAIL, \"e-postadress\",\r\n            FIELD_DATE, \"datum\",\r\n            FIELD_TIME, \"tid\",\r\n            FIELD_DESCRIPTION, \"beskrivningen\"\r\n\r\n    );\r\n\r\n    // Totalt antal möten\r\n    private static int totalMeetings;\r\n\r\n    /**\r\n     * Skapar en AppointmentRepository med en initial totalt möten-räkning på 0.\r\n     */\r\n    public AppointmentRepository() {\r\n        totalMeetings = 0;\r\n    }\r\n\r\n    /**\r\n     * Hämtar det aktuella antalet mötesposter i systemet.\r\n     *\r\n     * @return Antalet mötesposter i systemet.\r\n     */\r\n    public static int getRecordCount() {\r\n        return totalMeetings;\r\n    }\r\n\r\n    /**\r\n     * Initialiserar databasen genom att ladda JDBC-drivrutinen, skapa databas och tabell om de inte redan existerar samt ladda möten från databasen.\r\n     *\r\n     * @throws SQLException Kastas om det uppstår ett SQL-relaterat fel.\r\n     */\r\n    public void initializeDatabase() throws SQLException {\r\n        try {\r\n            // Ladda JDBC-drivrutinen\r\n            Class.forName(DRIVER);\r\n\r\n            // Skapa databas och tabell om de inte redan existerar\r\n            // DatabaseManager.createDatabaseAndTableIfNotExists();\r\n\r\n            // Ladda möten från databasen\r\n            loadTotalMeetings();\r\n        } catch (ClassNotFoundException e) {\r\n            // Logga fel med logger och kasta SQLException\r\n            logger.log(Level.SEVERE, \"JDBC-drivrutinen hittades inte\", e);\r\n            throw new SQLException(\"JDBC-drivrutinen hittades inte\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Laddar det totala antalet möten från databasen.\r\n     */\r\n\r\n    private void loadTotalMeetings() {\r\n        try (Connection connection = DatabaseManager.getConnection()) {\r\n            // Check if the connection is not null before proceeding\r\n            if (connection != null) {\r\n                try (Statement statement = connection.createStatement()) {\r\n                    String query = \"SELECT COUNT(*) FROM Appointments\";\r\n                    ResultSet resultSet = statement.executeQuery(query);\r\n\r\n                    if (resultSet.next()) {\r\n                        totalMeetings = resultSet.getInt(1);\r\n                    }\r\n                }\r\n            } else {\r\n                // Handle the case where the connection is null\r\n                System.err.println(\"Misslyckades att få en giltig databasanslutning.\");\r\n                // You might want to throw an exception or handle it according to your application's logic\r\n            }\r\n        } catch (SQLException e) {\r\n            handleSQLException(\"Fel vid inläsning av totalMeetings\", e);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Hanterar ett SQLException genom att skriva ut felmeddelandet och stacktrace till standardfelströmmen.\r\n     *\r\n     * @param message Beskrivande meddelande om det uppstådda felet.\r\n     * @param e SQLException som innehåller information om det uppstådda felet.\r\n     */\r\n    private void handleSQLException(String message, SQLException e) {\r\n        logger.log(Level.SEVERE, message + \": \" + e.getMessage(), e);\r\n    }\r\n\r\n    /**\r\n     * Lägger till ett möte i databasen.\r\n     *\r\n     * @param appointment Möte att lägga till.\r\n     * @throws IllegalArgumentException Om ett fel inträffar under insättning i databasen.\r\n     */\r\n    public void addAppointment(Appointment appointment) {\r\n        try (PreparedStatement preparedStatement = Objects.requireNonNull(DatabaseManager.getConnection()).prepareStatement(\r\n                \"INSERT INTO Appointments (Name, IdNumber, Email, Date, Time, Description) VALUES (?, ?, ?, ?, ?, ?)\")) {\r\n\r\n            preparedStatement.setString(1, appointment.getName());\r\n            preparedStatement.setString(2, appointment.getIdNumber());\r\n            preparedStatement.setString(3, appointment.getEmail());\r\n            preparedStatement.setString(4, appointment.getDate());\r\n            preparedStatement.setString(5, appointment.getTime());\r\n            preparedStatement.setString(6, appointment.getDescription());\r\n\r\n            preparedStatement.executeUpdate();\r\n\r\n            // Ökar totalMeetings-räkningen efter lyckad addition\r\n            totalMeetings++;\r\n\r\n        } catch (SQLException e) {\r\n            // Use a logger to log the error message and exception\r\n            Logger logger = Logger.getLogger(getClass().getName());\r\n            logger.log(Level.SEVERE, \"Fel vid läggning av möte i databasen: \" + e.getMessage(), e);\r\n\r\n            // Optionally, you can throw a more specific exception or handle the error as needed\r\n            throw new IllegalArgumentException(\"Fel vid läggning av möte i databasen: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Söker efter möten baserat på det angivna fältet och värdet.\r\n     *\r\n     * @param field Fältet att söka efter (t.ex., \"name\", \"idNumber\", \"date\").\r\n     * @param value Värdet som ska matchas i det angivna fältet.\r\n     * @throws InterruptedException Om det uppstår ett avbrott under sökningen.\r\n     */\r\n    public static void searchByField(String field, String value) throws InterruptedException {\r\n        if (getRecordCount() == 0) {\r\n            System.out.println(\"Inga möten att söka.\");\r\n            printReturningToMainMenu();\r\n            Thread.sleep(500);\r\n            return;\r\n        }\r\n\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME)) {\r\n            if (recordExistsByField(connection, field, value)) {\r\n                System.out.println(\"Mötet med det angivna värdet för fältet \" + getSwedishFieldName(field) + \" hittades:\");\r\n                try (PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM Appointments WHERE \" + field + \" = ?\")) {\r\n                    statement.setString(1, value);\r\n\r\n                    try (ResultSet resultSet = statement.executeQuery()) {\r\n                        while (resultSet.next()) {\r\n                            printAppointmentDetails(resultSet);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                System.out.println(\"Ingen post hittades med det angivna värdet för fältet \" + getSwedishFieldName(field) + \".\");\r\n            }\r\n        } catch (SQLException e) {\r\n            // Use a logger to log the error message and exception\r\n            Logger logger = Logger.getLogger(AppointmentRepository.class.getName());\r\n            logger.log(Level.SEVERE, \"Något gick fel vid sökningen.\", e);\r\n            askForContinue(\"sökning\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Skriver ut detaljer för ett möte från ResultSet till konsolen.\r\n     *\r\n     * @param resultSet ResultSet som innehåller mötesdetaljerna.\r\n     * @throws SQLException Om det uppstår ett SQL-relaterat fel vid åtkomst till ResultSet.\r\n     */\r\n    private static void printAppointmentDetails(ResultSet resultSet) throws SQLException {\r\n        System.out.println(\"Namn: \" + resultSet.getString(\"Name\"));\r\n        System.out.println(\"Personnummer: \" + resultSet.getString(\"IdNumber\"));\r\n        System.out.println(\"E-post: \" + resultSet.getString(\"Email\"));\r\n        System.out.println(\"Datum: \" + resultSet.getString(\"Date\"));\r\n        System.out.println(\"Tid: \" + resultSet.getString(\"Time\"));\r\n        System.out.println(\"Beskrivning: \" + resultSet.getString(\"Description\"));\r\n        System.out.println(\"------------------------------------------------------------\");\r\n    }\r\n\r\n    /**\r\n     * Kontrollerar om det finns en post i databasen som matchar det angivna fältet och värdet.\r\n     *\r\n     * @param connection En aktiv JDBC Connection.\r\n     * @param field      Fältet att söka efter (t.ex., \"name\", \"idNumber\", \"date\").\r\n     * @param value      Värdet som ska matchas i det angivna fältet.\r\n     * @return true om en matchande post finns, annars false.\r\n     * @throws SQLException om det uppstår ett SQL-relaterat fel.\r\n     */\r\n    private static boolean recordExistsByField(Connection connection, String field, String value) throws SQLException {\r\n        String query = \"SELECT 1 FROM Appointments WHERE \" + field + \" = ?\";\r\n\r\n        try (PreparedStatement checkStatement = connection.prepareStatement(query)) {\r\n            checkStatement.setString(1, value);\r\n            ResultSet resultSet = checkStatement.executeQuery();\r\n            return resultSet.next();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves an Appointment based on the specified field and value.\r\n     *\r\n     * @param field The field to search for (e.g., \"name\", \"idNumber\", \"date\").\r\n     * @param value The value to match in the specified field.\r\n     * @return The Appointment object if found, or null if not found.\r\n     * @throws SQLException If there is an SQL-related error during the retrieval.\r\n     */\r\n    public Appointment getAppointmentByField(String field, String value) throws SQLException {\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME)) {\r\n            if (recordExistsByField(connection, field, value)) {\r\n                try (PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM Appointments WHERE \" + field + \" = ?\")) {\r\n                    statement.setString(1, value);\r\n\r\n                    try (ResultSet resultSet = statement.executeQuery()) {\r\n                        if (resultSet.next()) {\r\n                            return new Appointment(\r\n                                    resultSet.getString(FIELD_NAME),\r\n                                    resultSet.getString(FIELD_ID_NUMBER),\r\n                                    resultSet.getString(FIELD_EMAIL),\r\n                                    resultSet.getString(FIELD_DATE),\r\n                                    resultSet.getString(FIELD_TIME),\r\n                                    resultSet.getString(FIELD_DESCRIPTION)\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Uppdaterar en mötespost i databasen baserat på det angivna fältet och det gamla värdet.\r\n     *\r\n     * @param field         Fältet att söka efter (t.ex., \"name\", \"idNumber\", \"date\").\r\n     * @param oldValue      Det gamla värdet i det angivna fältet.\r\n     * @param newAppointment En Appointment-objekt med uppdaterade värden.\r\n     * @throws SQLException Om det uppstår ett SQL-relaterat fel under uppdateringen.\r\n     */\r\n    void updateRecord(String field, String oldValue, Appointment newAppointment) throws SQLException {\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME)) {\r\n            // Kontrollera om posten finns innan uppdatering\r\n            if (!recordExistsByField(connection, field, oldValue)) {\r\n                System.out.println(\"Ingen post hittades med det angivna värdet för fältet.\");\r\n                return;\r\n            }\r\n\r\n            // Posten finns, fortsätt med uppdateringen\r\n            System.out.println(\"Uppdaterar informationen...\");\r\n            Thread.sleep(500);\r\n            System.out.println(\"Nytt namn: \" + newAppointment.getName());\r\n            System.out.println(\"Nytt personnummer: \" + newAppointment.getIdNumber());\r\n            System.out.println(\"Ny e-post: \" + newAppointment.getEmail());\r\n            System.out.println(\"Nytt datum: \" + newAppointment.getDate());\r\n            System.out.println(\"Ny tid: \" + newAppointment.getTime());\r\n            System.out.println(\"Ny beskrivning: \" + newAppointment.getDescription());\r\n            System.out.println(\"------------------------------------------------------------\");\r\n\r\n            try (PreparedStatement updateStatement = connection.prepareStatement(\r\n                    \"UPDATE Appointments SET name = ?, idNumber = ?, email = ?, date = ?, time = ?, description = ? WHERE \" + field + \" = ?\",\r\n                    Statement.NO_GENERATED_KEYS)) {\r\n\r\n                // Sätt parametrar för uppdateringsuttrycket\r\n                updateStatement.setString(1, newAppointment.getName());\r\n                updateStatement.setString(2, newAppointment.getIdNumber());\r\n                updateStatement.setString(3, newAppointment.getEmail());\r\n                updateStatement.setString(4, newAppointment.getDate());\r\n                updateStatement.setString(5, newAppointment.getTime());\r\n                updateStatement.setString(6, newAppointment.getDescription());\r\n                updateStatement.setString(7, oldValue);\r\n\r\n                int rowsAffected = updateStatement.executeUpdate();\r\n\r\n                if (rowsAffected > 0) {\r\n                    // Print the success message after updating the count\r\n                    totalMeetings++;\r\n                } else {\r\n                    System.out.println(\"Ingen post hittades med det angivna värdet för fältet.\");\r\n                }\r\n            } catch (SQLException e) {\r\n                handleSQLException(\"Fel vid uppdatering av möte\", e);\r\n            }\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hanterar resultatet av en raderingsförfrågan och visar lämpliga meddelanden.\r\n     *\r\n     * @param rowsAffected Antal rader påverkade av raderingsförfrågan.\r\n     * @param value        Värdet som raderades.\r\n     * @param fieldName    Namnet på fältet där raderingen skedde.\r\n     */\r\n    private void handleDeleteResult(int rowsAffected, String value, String fieldName) {\r\n        if (rowsAffected > 0) {\r\n            totalMeetings--;\r\n\r\n            if (totalMeetings == 0) {\r\n                // Återställ identitetsfröet för ID-kolumnen när totalMeetings når 0\r\n                resetIdentitySeed();\r\n            }\r\n\r\n            System.out.println(\"\\nPost med \" + getSwedishFieldName(fieldName) + \" '\" + value + \"' har raderats framgångsrikt!\");\r\n            System.out.println(\"Totalt antal möten i systemet: \" + totalMeetings + \"\\n\");\r\n        } else {\r\n            System.out.println(\"Ingen post hittades med \" + getSwedishFieldName(fieldName) + \" '\" + value + \"'.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Återställer identitetsfröet för ID-kolumnen i databasen.\r\n     */\r\n    private void resetIdentitySeed() {\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME);\r\n             Statement statement = connection.createStatement()) {\r\n\r\n            // Återställ identitetsfröet för ID-kolumnen\r\n            String resetIdentityQuery = \"DBCC CHECKIDENT ('Appointments', RESEED, 0)\";\r\n            statement.execute(resetIdentityQuery);\r\n\r\n            System.out.println(\"Identity seed för ID-kolumnen har återställts till 0.\");\r\n        } catch (SQLException e) {\r\n            handleSQLException(\"Fel vid återställning av identity seed\", e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Raderar en post från databasen baserat på ett angivet fältnamn och värde.\r\n     * Uppdaterar även totala mötesräkningen och återställer identitetsfröet vid behov.\r\n     *\r\n     * @param fieldName Fältnamn som ska matchas för att hitta posten.\r\n     * @param value     Värdet som används för att matcha och identifiera posten.\r\n     */\r\n    private void deleteRecordByField(String fieldName, String value) {\r\n        try (Connection connection = DatabaseManager.getConnection()) {\r\n            String deleteQuery = \"DELETE FROM Appointments WHERE \" + fieldName + \" = ?\";\r\n            assert connection != null;\r\n            try (PreparedStatement statement = connection.prepareStatement(deleteQuery)) {\r\n                statement.setString(1, value);\r\n                int rowsAffected = statement.executeUpdate();\r\n\r\n                handleDeleteResult(rowsAffected, value, fieldName);\r\n            }\r\n        } catch (SQLException e) {\r\n            handleSQLException(\"Fel vid radering av möte med \" + getSwedishFieldName(fieldName), e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hämtar det svenska fältnamnet för ett givet engelskt fältnamn.\r\n     *\r\n     * @param englishFieldName Det engelska fältnamnet.\r\n     * @return Det svenska fältnamnet om det finns, annars det engelska fältnamnet.\r\n     */\r\n    static String getSwedishFieldName(String englishFieldName) {\r\n        return SWEDISH_FIELD_NAMES.getOrDefault(englishFieldName, englishFieldName);\r\n    }\r\n\r\n    /**\r\n     * Raderar möten baserat på namn.\r\n     *\r\n     * @param nameToDelete Namnet på mötet som ska raderas.\r\n     */\r\n    public void deleteAppointmentByName(String nameToDelete) {\r\n        deleteRecordByField(FIELD_NAME, nameToDelete);\r\n    }\r\n\r\n    /**\r\n     * Raderar möten baserat på personnummer.\r\n     *\r\n     * @param idNumberToDelete Personnummer för mötet som ska raderas.\r\n     */\r\n    public void deleteAppointmentByIdNumber(String idNumberToDelete) {\r\n        deleteRecordByField(FIELD_ID_NUMBER, idNumberToDelete);\r\n    }\r\n\r\n    /**\r\n     * Raderar möten baserat på datum.\r\n     *\r\n     * @param dateToDelete Datumet för mötet som ska raderas.\r\n     */\r\n    public void deleteAppointmentByDate(String dateToDelete) {\r\n        deleteRecordByField(FIELD_DATE, dateToDelete);\r\n    }\r\n\r\n    /**\r\n     * Raderar alla möten från databasen.\r\n     */\r\n    public void deleteAllRecords() {\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME);\r\n             Statement statement = connection.createStatement()) {\r\n\r\n            // Om totalMeetings är 0, återgå till huvudmenyn\r\n            if (totalMeetings == 0) {\r\n                System.out.println(\"Inga poster att radera.\");\r\n                System.out.println(\"Återgår till huvudmenyn...\");\r\n                return;\r\n            }\r\n\r\n            // Fråga om bekräftelse för att radera alla möten\r\n            System.out.println(\"Varning: Detta kommer att radera alla möten. Är du säker? (ja/nej):\");\r\n            String confirmation = inputReader.nextLine(); // Använd inputReader istället för scanner\r\n\r\n            if (confirmation.equalsIgnoreCase(\"ja\")) {\r\n                String deleteQuery = \"DELETE FROM Appointments\";\r\n                int rowsAffected = statement.executeUpdate(deleteQuery);\r\n\r\n                if (rowsAffected > 0) {\r\n                    totalMeetings = 0;\r\n\r\n                    // Återställ identitetsfröet för ID-kolumnen\r\n                    String resetIdentityQuery = \"DBCC CHECKIDENT ('Appointments', RESEED, 0)\";\r\n                    statement.execute(resetIdentityQuery);\r\n\r\n                    System.out.println(\"Alla poster har raderats framgångsrikt!\");\r\n                    System.out.println(\"Totalt antal möten i systemet: \" + totalMeetings + \"\\n\");\r\n                } else {\r\n                    System.out.println(\"Inga poster hittades att radera.\");\r\n                }\r\n            } else {\r\n                System.out.println(\"Radering av alla möten avbruten.\");\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            handleSQLException(\"Fel vid radering av alla poster\", e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visar alla mötesposter i databasen.\r\n     *\r\n     * @throws SQLException Om det uppstår ett SQL-relaterat fel.\r\n     */\r\n    public void showRecords() throws SQLException {\r\n        String query = \"SELECT * FROM Appointments\";\r\n\r\n        try (Connection connection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME);\r\n             Statement statement = connection.createStatement();\r\n             ResultSet resultSet = statement.executeQuery(query)) {\r\n\r\n            int totalMeetings = 0;\r\n\r\n            while (resultSet.next()) {\r\n                int id = resultSet.getInt(\"id\");\r\n                String name = resultSet.getString(FIELD_NAME);\r\n                String idNumber = resultSet.getString(FIELD_ID_NUMBER);\r\n                String email = resultSet.getString(FIELD_EMAIL);\r\n                String date = resultSet.getString(FIELD_DATE);\r\n                String time = resultSet.getString(FIELD_TIME);\r\n                String description = resultSet.getString(FIELD_DESCRIPTION);\r\n\r\n                System.out.println(\"ID: \" + id);\r\n                System.out.println(\"Namn: \" + name);\r\n                System.out.println(\"Personnummer: \" + idNumber);\r\n                System.out.println(\"E-post: \" + email);\r\n                System.out.println(\"Datum: \" + date);\r\n                System.out.println(\"Tid: \" + time);\r\n                System.out.println(\"Beskrivning: \" + description);\r\n                System.out.println(\"------------------------------------------------------------\");\r\n\r\n                totalMeetings++;\r\n            }\r\n\r\n            System.out.println(\"\\nTotalt antal möten i systemet: \" + totalMeetings + \"\\n\");\r\n\r\n        } catch (SQLException e) {\r\n            System.err.println(\"Fel vid visning av poster: \" + e.getMessage());\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stänger inputläsaren.\r\n     */\r\n    public void closeInputReader() {\r\n        inputReader.closeScanner(); // Se till att skannern stängs när den behövs\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/projektarbete/AppointmentRepository.java b/src/main/java/org/projektarbete/AppointmentRepository.java
--- a/src/main/java/org/projektarbete/AppointmentRepository.java	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
+++ b/src/main/java/org/projektarbete/AppointmentRepository.java	(date 1706237483850)
@@ -24,7 +24,6 @@
     private static final String FIELD_DATE = "date";
     private static final String FIELD_TIME = "time";
     private static final String FIELD_DESCRIPTION = "Description";
-
     // Konstanter för JDBC URL och databasnamn
     private static final String JDBC_URL = DatabaseManager.getJDBCUrl();
     private static final String DATABASE_NAME = DatabaseManager.getDatabaseName();
@@ -90,7 +89,7 @@
 
     private void loadTotalMeetings() {
         try (Connection connection = DatabaseManager.getConnection()) {
-            // Check if the connection is not null before proceeding
+            // Kontrollera om anslutningen inte är null innan du fortsätter
             if (connection != null) {
                 try (Statement statement = connection.createStatement()) {
                     String query = "SELECT COUNT(*) FROM Appointments";
@@ -101,16 +100,14 @@
                     }
                 }
             } else {
-                // Handle the case where the connection is null
+                // Hantera fallet när anslutningen är null
                 System.err.println("Misslyckades att få en giltig databasanslutning.");
-                // You might want to throw an exception or handle it according to your application's logic
             }
         } catch (SQLException e) {
             handleSQLException("Fel vid inläsning av totalMeetings", e);
         }
     }
 
-
     /**
      * Hanterar ett SQLException genom att skriva ut felmeddelandet och stacktrace till standardfelströmmen.
      *
@@ -144,11 +141,10 @@
             totalMeetings++;
 
         } catch (SQLException e) {
-            // Use a logger to log the error message and exception
+            // Använd en logger för att logga felmeddelandet och undantaget
             Logger logger = Logger.getLogger(getClass().getName());
             logger.log(Level.SEVERE, "Fel vid läggning av möte i databasen: " + e.getMessage(), e);
 
-            // Optionally, you can throw a more specific exception or handle the error as needed
             throw new IllegalArgumentException("Fel vid läggning av möte i databasen: " + e.getMessage(), e);
         }
     }
@@ -191,8 +187,6 @@
         }
     }
 
-
-
     /**
      * Skriver ut detaljer för ett möte från ResultSet till konsolen.
      *
@@ -229,12 +223,12 @@
     }
 
     /**
-     * Retrieves an Appointment based on the specified field and value.
+     * Hämtar ett möte baserat på det angivna fältet och värdet.
      *
-     * @param field The field to search for (e.g., "name", "idNumber", "date").
-     * @param value The value to match in the specified field.
-     * @return The Appointment object if found, or null if not found.
-     * @throws SQLException If there is an SQL-related error during the retrieval.
+     * @param field Fältet att söka efter (t.ex., "name", "idNumber", "date").
+     * @param value Värdet som ska matchas i det angivna fältet.
+     * @return Appointment-objektet om det hittas, annars null.
+     * @throws SQLException om det uppstår ett SQL-relaterat fel under hämtningen.
      */
     public Appointment getAppointmentByField(String field, String value) throws SQLException {
         try (Connection connection = DriverManager.getConnection(JDBC_URL + ";databaseName=" + DATABASE_NAME)) {
@@ -304,7 +298,7 @@
                 int rowsAffected = updateStatement.executeUpdate();
 
                 if (rowsAffected > 0) {
-                    // Print the success message after updating the count
+                    // Uppdatera totalMeetings-räkningen efter lyckad uppdatering
                     totalMeetings++;
                 } else {
                     System.out.println("Ingen post hittades med det angivna värdet för fältet.");
@@ -328,8 +322,8 @@
         if (rowsAffected > 0) {
             totalMeetings--;
 
-            if (totalMeetings == 0) {
-                // Återställ identitetsfröet för ID-kolumnen när totalMeetings når 0
+            // Kolla alltid om det finns fler poster i tabellen innan du återställer identitetsfröet
+            if (!hasRecordsInTable()) {
                 resetIdentitySeed();
             }
 
@@ -340,6 +334,28 @@
         }
     }
 
+    /**
+     * Kontrollerar om det finns poster i tabellen.
+     *
+     * @return true om det finns poster, annars false.
+     */
+    private boolean hasRecordsInTable() {
+        try (Connection connection = DriverManager.getConnection(JDBC_URL + ";databaseName=" + DATABASE_NAME);
+             Statement statement = connection.createStatement()) {
+
+            ResultSet resultSet = statement.executeQuery("SELECT COUNT(*) FROM Appointments");
+
+            if (resultSet.next()) {
+                int count = resultSet.getInt(1);
+                return count > 0;
+            }
+        } catch (SQLException e) {
+            handleSQLException("Fel vid kontroll av antal poster i tabellen", e);
+        }
+        return false;
+    }
+
+
     /**
      * Återställer identitetsfröet för ID-kolumnen i databasen.
      */
Index: src/main/java/org/projektarbete/UserInterface.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.projektarbete;\r\nimport java.util.InputMismatchException;\r\n\r\n/**\r\n * En klass som representerar användargränssnittet för möteshanteringsapplikationen.\r\n */\r\npublic class UserInterface {\r\n\r\n    /**\r\n     * Alternativ för att lägga till ett nytt möte.\r\n     */\r\n    public static final int ADD_APPOINTMENT_OPTION = 1;\r\n\r\n    /**\r\n     * Alternativ för att söka efter ett möte.\r\n     */\r\n    public static final int SEARCH_APPOINTMENT_OPTION = 2;\r\n\r\n    /**\r\n     * Alternativ för att uppdatera ett möte.\r\n     */\r\n    public static final int UPDATE_APPOINTMENT_OPTION = 3;\r\n\r\n    /**\r\n     * Alternativ för att ta bort ett möte.\r\n     */\r\n    public static final int DELETE_APPOINTMENT_OPTION = 4;\r\n\r\n    /**\r\n     * Alternativ för att visa alla schemalagda möten.\r\n     */\r\n    public static final int SHOW_ALL_APPOINTMENTS_OPTION = 5;\r\n\r\n    /**\r\n     * Alternativ för att avsluta programmet.\r\n     */\r\n    public static final int EXIT_OPTION = 6;\r\n\r\n    /**\r\n     * En instans av InputReader för att hantera användarinmatning.\r\n     */\r\n    private static final InputReader inputReader = new InputReader();\r\n\r\n    /**\r\n     * Visar huvudmenyn för användaren och hanterar deras val.\r\n     */\r\n    public static void mainMenuOptions() {\r\n        int option;\r\n\r\n        do {\r\n            displayMainMenu();\r\n\r\n            while (true) {\r\n                try {\r\n                    option = inputReader.nextInt();\r\n                    break;\r\n                } catch (InputMismatchException e) {\r\n                    System.out.println(\"Var god ange ett giltigt heltal.\");\r\n                    inputReader.nextLine();\r\n                }\r\n            }\r\n\r\n            processMainMenuOption(option);\r\n\r\n        } while (option != EXIT_OPTION);\r\n    }\r\n\r\n    /**\r\n     * Visar huvudmenyn för mötesapplikationen.\r\n     */\r\n    static void displayMainMenu() {\r\n        System.out.println(\"------------------------------------------------------------\");\r\n        System.out.println(\"                       MÖTESCHEMA\");\r\n        System.out.println(\"------------------------------------------------------------\\n\");\r\n\r\n        System.out.println(\" ANGE ETT ALTERNATIV\\n\");\r\n        displayOption(ADD_APPOINTMENT_OPTION, \"LÄGG TILL NYTT MÖTE\");\r\n        displayOption(SEARCH_APPOINTMENT_OPTION, \"SÖK MÖTE\");\r\n        displayOption(UPDATE_APPOINTMENT_OPTION, \"UPPDATERA MÖTE\");\r\n        displayOption(DELETE_APPOINTMENT_OPTION, \"TA BORT MÖTE\");\r\n        displayOption(SHOW_ALL_APPOINTMENTS_OPTION, \"VISA ALLA MÖTEN\");\r\n        displayOption(EXIT_OPTION, \"AVSLUTA PROGRAMMET\");\r\n\r\n        System.out.println(\"------------------------------------------------------------\\n\");\r\n    }\r\n\r\n    /**\r\n     * Visar ett menyalternativ med en beskrivning.\r\n     *\r\n     * @param option      Det numeriska värdet för menyalternativet.\r\n     * @param description Beskrivningen av menyalternativet.\r\n     */\r\n    static void displayOption(int option, String description) {\r\n        System.out.printf(\" %d - %-30s%n\", option, description);\r\n    }\r\n\r\n    /**\r\n     * Hanterar användarens val från huvudmenyn.\r\n     *\r\n     * @param option Användarens val.\r\n     */\r\n    static void processMainMenuOption(int option) {\r\n        System.out.println(\"Bearbetar alternativ: \" + option);\r\n        switch (option) {\r\n            case ADD_APPOINTMENT_OPTION:\r\n                displaySubMenu(\"Lägg till nytt möte\");\r\n                AppointmentAgenda.addAppointment();\r\n                break;\r\n            case SEARCH_APPOINTMENT_OPTION:\r\n                displaySubMenu(\"Söker...\");\r\n                AppointmentAgenda.searchMenu();\r\n                displaySubMenu(\"Slutet på sökningen\");\r\n                break;\r\n            case UPDATE_APPOINTMENT_OPTION:\r\n                displaySubMenu(\"Uppdatera möte\");\r\n                AppointmentAgenda.updateMenu();\r\n                break;\r\n            case DELETE_APPOINTMENT_OPTION:\r\n                displaySubMenu(\"Ta bort möte\");\r\n                AppointmentAgenda.deleteMenu();\r\n                break;\r\n            case SHOW_ALL_APPOINTMENTS_OPTION:\r\n                displaySubMenu(\"Schemalagda möten\");\r\n                AppointmentAgenda.showAppointments();\r\n                displaySubMenu(\"Slut på samråd\");\r\n                break;\r\n            case EXIT_OPTION:\r\n                System.out.println(\"Avslutar programmet. Adjö!\");\r\n                break;\r\n            default:\r\n                System.out.println(\"Ogiltigt alternativ\");\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visar en undermeny med en given titel.\r\n     *\r\n     * @param title Titeln på undermenyn.\r\n     */\r\n    static void displaySubMenu(String title) {\r\n        System.out.println(\"------------------------------------------------------------\");\r\n        System.out.printf(\"                     %s%n\", title);\r\n        System.out.println(\"------------------------------------------------------------\\n\");\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/projektarbete/UserInterface.java b/src/main/java/org/projektarbete/UserInterface.java
--- a/src/main/java/org/projektarbete/UserInterface.java	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
+++ b/src/main/java/org/projektarbete/UserInterface.java	(date 1706232536652)
@@ -70,7 +70,7 @@
      */
     static void displayMainMenu() {
         System.out.println("------------------------------------------------------------");
-        System.out.println("                       MÖTESCHEMA");
+        System.out.println("                      MÖTESSCHEMA");
         System.out.println("------------------------------------------------------------\n");
 
         System.out.println(" ANGE ETT ALTERNATIV\n");
Index: src/main/java/org/projektarbete/DatabaseManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.projektarbete;\r\nimport java.sql.*;\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.SQLException;\r\nimport java.util.logging.Level;\r\nimport java.util.logging.Logger;\r\n\r\npublic class DatabaseManager {\r\n\r\n    private static final String SERVER_NAME = \"localhost\";\r\n    private static final String DATABASE_NAME = \"AppointmentScheduler\";\r\n    static final String DRIVER = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\r\n\r\n    private static final String JDBC_URL = \"jdbc:sqlserver://\" + SERVER_NAME + \":1433;integratedSecurity=true;encrypt=true;trustServerCertificate=true;\";\r\n    private static Connection connection;\r\n    static Logger logger = Logger.getLogger(DatabaseManager.class.getName());\r\n\r\n    static {\r\n        Runtime.getRuntime().addShutdownHook(new Thread(DatabaseManager::closeConnection));\r\n    }\r\n\r\n    static void createDatabaseIfNotExists() throws SQLException {\r\n        try (Connection localConnection = DriverManager.getConnection(JDBC_URL);\r\n             Statement statement = localConnection.createStatement()) {\r\n\r\n            String checkDatabaseQuery = \"SELECT 1 FROM sys.databases WHERE name = '\" + DATABASE_NAME + \"'\";\r\n            ResultSet resultSet = statement.executeQuery(checkDatabaseQuery);\r\n\r\n            if (!resultSet.next()) {\r\n                String createDatabaseQuery = \"CREATE DATABASE \" + DATABASE_NAME;\r\n                statement.executeUpdate(createDatabaseQuery);\r\n                System.out.println(\"Databasen har skapats framgångsrikt!\");\r\n            } else {\r\n                System.out.println(\"Databasen har redan skapats tidigare.\");\r\n            }\r\n\r\n            connection = localConnection;\r\n\r\n        } catch (SQLException e) {\r\n            logError(\"Fel vid skapande eller granskning av databas: \" + e.getMessage());\r\n            logger.log(Level.SEVERE, \"Fel vid skapande eller granskning av databas\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    static void createTableIfNotExists() throws SQLException {\r\n        try (Connection dbConnection = DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME);\r\n             Statement dbStatement = dbConnection.createStatement()) {\r\n\r\n            String checkTableQuery = \"SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'Appointments'\";\r\n            ResultSet resultSet = dbStatement.executeQuery(checkTableQuery);\r\n\r\n            if (!resultSet.next()) {\r\n                String createTableQuery = \"CREATE TABLE Appointments ( \" +\r\n                        \"Id INT PRIMARY KEY IDENTITY(1,1), \" +\r\n                        \"Name NVARCHAR(MAX), \" +\r\n                        \"IdNumber NVARCHAR(20), \" +\r\n                        \"Email NVARCHAR(50), \" +\r\n                        \"Date NVARCHAR(20), \" +\r\n                        \"Time NVARCHAR(20), \" +\r\n                        \"Description NVARCHAR(MAX) \" +\r\n                        \")\";\r\n                dbStatement.executeUpdate(createTableQuery);\r\n                System.out.println(\"Tabellen har skapats framgångsrikt!\");\r\n            } else {\r\n                System.out.println(\"Tabellen har redan skapats tidigare.\");\r\n            }\r\n\r\n        } catch (SQLException e) {\r\n            logError(\"Fel vid skapande eller granskning av tabell: \" + e.getMessage());\r\n            logger.log(Level.SEVERE, \"Fel vid skapande eller granskning av tabell\", e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    static void createDatabaseAndTableIfNotExists() throws SQLException {\r\n        createDatabaseIfNotExists();\r\n        createTableIfNotExists();\r\n    }\r\n\r\n    /**\r\n     * Etablerar en anslutning till databasen.\r\n     *\r\n     * @return Connection-objekt om det är framgångsrikt, annars null.\r\n     */\r\n    public static Connection getConnection() {\r\n        try {\r\n            // Försök skapa en anslutning\r\n            return DriverManager.getConnection(JDBC_URL + \";databaseName=\" + DATABASE_NAME + \";integratedSecurity=true;encrypt=true;trustServerCertificate=true;\");\r\n        } catch (SQLException e) {\r\n            // Logga fel med logger\r\n            logger.log(Level.SEVERE, \"Fel vid etablering av databasanslutning: \" + e.getMessage(), e);\r\n            return null; // Returnera null om anslutningen inte kunde upprättas\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returnerar JDBC URL för databasanslutningen.\r\n     *\r\n     * @return JDBC URL\r\n     */\r\n    public static String getJDBCUrl() {\r\n        return JDBC_URL + \";databaseName=\" + DATABASE_NAME;\r\n    }\r\n\r\n    /**\r\n     * Returnerar namnet på databasen.\r\n     *\r\n     * @return Databasens namn\r\n     */\r\n    public static String getDatabaseName() {\r\n        return DATABASE_NAME;\r\n    }\r\n\r\n    /**\r\n     * Stänger databasanslutningen.\r\n     */\r\n    public static void closeConnection() {\r\n        try {\r\n            // Stäng anslutningen om den inte redan är stängd\r\n            if (connection != null && !connection.isClosed()) {\r\n                connection.close();\r\n                System.out.println(\"Databasanslutning stängd.\");\r\n            }\r\n        } catch (SQLException e) {\r\n            // Logga fel med logger\r\n            logger.log(Level.SEVERE, \"Fel vid stängning av databasanslutning: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loggar ett felmeddelande.\r\n     *\r\n     * @param errorMessage Felmeddelandet att logga.\r\n     */\r\n    static void logError(String errorMessage) {\r\n        logger.log(Level.SEVERE, errorMessage);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/projektarbete/DatabaseManager.java b/src/main/java/org/projektarbete/DatabaseManager.java
--- a/src/main/java/org/projektarbete/DatabaseManager.java	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
+++ b/src/main/java/org/projektarbete/DatabaseManager.java	(date 1706232494101)
@@ -30,9 +30,9 @@
             if (!resultSet.next()) {
                 String createDatabaseQuery = "CREATE DATABASE " + DATABASE_NAME;
                 statement.executeUpdate(createDatabaseQuery);
-                System.out.println("Databasen har skapats framgångsrikt!");
+                System.out.println("Ditt MÖTESSCHEMA har skapats framgångsrikt!");
             } else {
-                System.out.println("Databasen har redan skapats tidigare.");
+                System.out.println("Välkommen tillbaka!");
             }
 
             connection = localConnection;
@@ -62,9 +62,9 @@
                         "Description NVARCHAR(MAX) " +
                         ")";
                 dbStatement.executeUpdate(createTableQuery);
-                System.out.println("Tabellen har skapats framgångsrikt!");
+                System.out.println("Lägg till ditt första möte.");
             } else {
-                System.out.println("Tabellen har redan skapats tidigare.");
+                System.out.println("Data från den senaste anslutningen finns kvar i systemet.");
             }
 
         } catch (SQLException e) {
Index: src/main/java/org/projektarbete/Validation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.projektarbete;\r\nimport java.time.LocalDate;\r\nimport java.time.LocalDateTime;\r\nimport java.time.LocalTime;\r\nimport java.time.format.DateTimeParseException;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n * Klassen innehåller metoder för att validera olika fält i ett mötesformulär.\r\n */\r\npublic class Validation {\r\n\r\n    /**\r\n     * Validerar samtliga fält i mötesformuläret.\r\n     *\r\n     * @param name        Namnet som ska valideras.\r\n     * @param idNumber    Personnumret som ska valideras.\r\n     * @param email       E-postadressen som ska valideras.\r\n     * @param date        Datumet som ska valideras.\r\n     * @param time        Tiden som ska valideras.\r\n     * @param description Beskrivningen som ska valideras.\r\n     * @return Lista med felmeddelanden, om några valideringsfel uppstår.\r\n     */\r\n    public static List<String> validateAllFields(String name, String idNumber, String email, String date, String time, String description) {\r\n        List<String> errorMessages = new ArrayList<>();\r\n\r\n        validateName(name, errorMessages);\r\n        validateIdNumber(idNumber, errorMessages);\r\n        validateEmail(email, errorMessages);\r\n        validateDate(date, errorMessages);\r\n        validateTime(time, date, errorMessages); // Skicka med datum för tidsvalidering\r\n        validateDescription(description, errorMessages);\r\n\r\n        // Kontrollera om det finns några valideringsfel\r\n        if (!errorMessages.isEmpty()) {\r\n            return errorMessages; // Stoppa vidare bearbetning om det finns fel\r\n        }\r\n\r\n        // Fortsätt med ytterligare bearbetning (t.ex. spara mötet)\r\n\r\n        // Om det finns ytterligare logik efter validering, placera den här\r\n\r\n        return errorMessages;\r\n    }\r\n\r\n    /**\r\n     * Validerar namnfältet.\r\n     *\r\n     * @param name          Namnet som ska valideras.\r\n     * @param errorMessage  Lista för att lagra felmeddelanden vid validering.\r\n     * @throws IllegalArgumentException om namnet är null eller tomt.\r\n     * @implNote Ytterligare specifik valideringslogik för namn kan läggas till vid behov.\r\n     */\r\n    public static void validateName(String name, List<String> errorMessage) {\r\n        if (name == null || name.trim().isEmpty()) {\r\n            errorMessage.add(\"Namnet får inte vara null eller tomt.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validerar Personnumret fältet.\r\n     *\r\n     * @param idNumber      Personnumret som ska valideras.\r\n     * @param errorMessage  Lista för att lagra felmeddelanden vid validering.\r\n     * @throws IllegalArgumentException om ID-numret är null eller inte är 10 siffror långt.\r\n     * @implNote Ytterligare specifik valideringslogik för ID-nummer kan läggas till vid behov.\r\n     */\r\n    public static void validateIdNumber(String idNumber, List<String> errorMessage) {\r\n        String cleanIdNumber = idNumber.trim().replaceAll(\"\\\\s+\", \"\");\r\n        if (cleanIdNumber.length() != 10 || !cleanIdNumber.matches(\"\\\\d{10}\")) {\r\n            errorMessage.add(\"Ogiltigt personnummer. Personnumret måste vara exakt 10 siffror utan andra tecken.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validerar e-postadressfältet.\r\n     *\r\n     * @param email         E-postadressen som ska valideras.\r\n     * @param errorMessage  Lista för att lagra felmeddelanden vid validering.\r\n     * @throws IllegalArgumentException om e-postadressen är ogiltig.\r\n     */\r\n    public static void validateEmail(String email, List<String> errorMessage) {\r\n        String emailRegex = \"^[a-zA-Z0-9_+&*-]+(?:\\\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\\\.)+[a-zA-Z]{2,7}$\";\r\n        if (!Pattern.matches(emailRegex, email)) {\r\n            errorMessage.add(\"Ogiltig e-postadressformat. Använd t.ex. användarnamn@domän.com.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validerar datumfältet.\r\n     *\r\n     * @param date          Datumet som ska valideras.\r\n     * @param errorMessage  Lista för att lagra felmeddelanden vid validering.\r\n     * @throws IllegalArgumentException om datumet är ogiltigt.\r\n     */\r\n    public static void validateDate(String date, List<String> errorMessage) {\r\n        if (date == null || !date.matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\")) {\r\n            errorMessage.add(\"Ogiltigt datumformat. Använd ÅÅÅÅ-MM-DD.\");\r\n            return;  // Stoppa vidare bearbetning om formatet är ogiltigt\r\n        }\r\n\r\n        try {\r\n            LocalDate providedDate = LocalDate.parse(date);\r\n\r\n            if (providedDate.isBefore(LocalDate.now())) {\r\n                errorMessage.add(\"Datumet måste vara i framtiden.\");\r\n            }\r\n        } catch (DateTimeParseException e) {\r\n            errorMessage.add(\"Ogiltigt datum. Försök igen.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validerar tidsfältet.\r\n     *\r\n     * @param time          Tiden som ska valideras.\r\n     * @param date          Datumet som används för tidsvalidering.\r\n     * @param errorMessage  Lista för att lagra felmeddelanden vid validering.\r\n     * @throws IllegalArgumentException om tiden är ogiltig.\r\n     */\r\n    public static void validateTime(String time, String date, List<String> errorMessage) {\r\n        if (time == null || !time.matches(\"([01]?[0-9]|2[0-3]):[0-5][0-9]\")) {\r\n            errorMessage.add(\"Ogiltigt tidsformat. Använd HH:MM.\");\r\n            return;  // Stoppa vidare bearbetning om formatet är ogiltigt\r\n        }\r\n\r\n        try {\r\n            LocalTime providedTime = LocalTime.parse(time);\r\n            LocalDateTime currentDateTime = LocalDateTime.now();\r\n            LocalDate providedDate = LocalDate.parse(date);\r\n\r\n            if (providedDate.isEqual(currentDateTime.toLocalDate()) && providedTime.isBefore(currentDateTime.toLocalTime())) {\r\n                errorMessage.add(\"Tiden måste vara i framtiden.\");\r\n            }\r\n        } catch (DateTimeParseException e) {\r\n            errorMessage.add(\"Ogiltig tid. Försök igen.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validerar beskrivningsfältet.\r\n     *\r\n     * @param description   Beskrivningen som ska valideras.\r\n     * @param errorMessage  Lista för att lagra felmeddelanden vid validering.\r\n     * @throws IllegalArgumentException om beskrivningen är null eller tom.\r\n     * @implNote Ytterligare specifik valideringslogik för beskrivning kan läggas till vid behov.\r\n     */\r\n    public static void validateDescription(String description, List<String> errorMessage) {\r\n        if (description == null || description.trim().isEmpty()) {\r\n            errorMessage.add(\"Beskrivningen får inte vara null eller tom.\");\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/projektarbete/Validation.java b/src/main/java/org/projektarbete/Validation.java
--- a/src/main/java/org/projektarbete/Validation.java	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
+++ b/src/main/java/org/projektarbete/Validation.java	(date 1706233615354)
@@ -70,7 +70,7 @@
     public static void validateIdNumber(String idNumber, List<String> errorMessage) {
         String cleanIdNumber = idNumber.trim().replaceAll("\\s+", "");
         if (cleanIdNumber.length() != 10 || !cleanIdNumber.matches("\\d{10}")) {
-            errorMessage.add("Ogiltigt personnummer. Personnumret måste vara exakt 10 siffror utan andra tecken.");
+            errorMessage.add("Ogiltigt personnummer. Använd 10 siffror.");
         }
     }
 
@@ -84,7 +84,7 @@
     public static void validateEmail(String email, List<String> errorMessage) {
         String emailRegex = "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";
         if (!Pattern.matches(emailRegex, email)) {
-            errorMessage.add("Ogiltig e-postadressformat. Använd t.ex. användarnamn@domän.com.");
+            errorMessage.add("Ogiltig e-postadressformat. T.ex. användarnamn@domän.com.");
         }
     }
 
Index: src/test/java/org/projektarbete/UserInterfaceTest.java
===================================================================
diff --git a/src/test/java/org/projektarbete/UserInterfaceTest.java b/src/test/java/org/projektarbete/UserInterfaceTest.java
deleted file mode 100644
--- a/src/test/java/org/projektarbete/UserInterfaceTest.java	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
+++ /dev/null	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
@@ -1,111 +0,0 @@
-package org.projektarbete;
-
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.io.PrintStream;
-
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-public class UserInterfaceTest {
-
-    private InputStream originalSystemIn;
-    private PrintStream originalSystemOut;
-
-    @BeforeEach
-    public void setUp() {
-        originalSystemIn = System.in;
-        originalSystemOut = System.out;
-    }
-
-    @AfterEach
-    public void tearDown() {
-        System.setIn(originalSystemIn);
-        System.setOut(originalSystemOut);
-    }
-
-    /**
-     * Testar metoden displayMainMenu i UserInterface.
-     * Den redirectar System.out för att fånga det utskrivna resultatet,
-     * kallar på displayMainMenu och jämför det förväntade resultatet med det fångade resultatet.
-     */
-    @Test
-    public void testDisplayMainMenu() {
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        System.setOut(new PrintStream(outputStream));
-
-        UserInterface.displayMainMenu();
-
-        String menuOutput = outputStream.toString();
-
-        assertTrue(menuOutput.contains("LÄGG TILL NYTT MÖTE"));
-        assertTrue(menuOutput.contains("SÖK MÖTE"));
-    }
-
-    /**
-     * Testar metoden processMainMenuOption med alternativet för att lägga till ett nytt möte.
-     * Mockar användarinput för att simulera valet av "LÄGG TILL NYTT MÖTE",
-     * redirectar System.out för att fånga det utskrivna resultatet,
-     * kallar på processMainMenuOption och jämför det förväntade resultatet med det fångade resultatet.
-     */
-    @Test
-    public void testProcessMainMenuOption_AddAppointmentOption() {
-        InputStream inputStream = new ByteArrayInputStream("1\n".getBytes());
-        System.setIn(inputStream);
-
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        System.setOut(new PrintStream(outputStream));
-
-        UserInterface.processMainMenuOption(UserInterface.ADD_APPOINTMENT_OPTION);
-
-        String output = outputStream.toString();
-
-        assertTrue(output.contains("Lägg till nytt möte"));
-    }
-
-    /**
-     * Testar hantering av InputMismatchException.
-     * Mockar användarinput för att simulera att användaren anger en icke-integer,
-     * redirectar System.out för att fånga det utskrivna resultatet,
-     * kallar på mainMenuOptions och jämför det förväntade resultatet med det fångade resultatet.
-     */
-    @Test
-    public void testInputMismatchExceptionHandling() {
-        InputStream inputStream = new ByteArrayInputStream("abc\n".getBytes());
-        System.setIn(inputStream);
-
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        System.setOut(new PrintStream(outputStream));
-
-        UserInterface.mainMenuOptions();
-
-        String output = outputStream.toString();
-
-        assertTrue(output.contains("Var god ange ett giltigt heltal."));
-    }
-
-    /**
-     * Testar hantering av NoSuchElementException.
-     * Mockar användarinput för att simulera att ingen input är tillgänglig,
-     * redirectar System.out för att fånga det utskrivna resultatet,
-     * kallar på mainMenuOptions och jämför det förväntade resultatet med det fångade resultatet.
-     */
-    @Test
-    public void testNoSuchElementExceptionHandling() {
-        InputStream inputStream = new ByteArrayInputStream("".getBytes());
-        System.setIn(inputStream);
-
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        System.setOut(new PrintStream(outputStream));
-
-        UserInterface.mainMenuOptions();
-
-        String output = outputStream.toString();
-
-        assertTrue(output.contains("Var god ange ett giltigt heltal."));
-    }
-}
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"b1293931-78f6-405f-9cb5-3f3848f0f5e1\" name=\"Changes\" comment=\"Uppdatera med tester\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"PUSH_AUTO_UPDATE\" value=\"true\" />\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;history&quot;: [\r\n    {\r\n      &quot;state&quot;: &quot;OPEN&quot;,\r\n      &quot;assignee&quot;: &quot;IgorGomes01&quot;,\r\n      &quot;author&quot;: &quot;IgorGomes01&quot;\r\n    }\r\n  ],\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;IgorGomes01&quot;,\r\n    &quot;author&quot;: &quot;IgorGomes01&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">\r\n    <option name=\"selectedUrlAndAccountId\">\r\n      <UrlAndAccount>\r\n        <option name=\"accountId\" value=\"e83f9eef-55c4-4ae3-a6c5-3fafc92c9bf1\" />\r\n        <option name=\"url\" value=\"https://github.com/unikhex/Java-group-work\" />\r\n      </UrlAndAccount>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProblemsViewState\">\r\n    <option name=\"selectedTabId\" value=\"CurrentFile\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2aifXs9yIRRaT0JvTY28XycGe4T\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Application.Appointment.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.AppointmentAgenda.executor&quot;: &quot;Run&quot;,\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;JUnit.AppointmentTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.DatabaseManagerTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.UserInterfaceTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;JUnit.ValidationTest.executor&quot;: &quot;Run&quot;,\r\n    &quot;Maven.Javagroupwork [clean].executor&quot;: &quot;Run&quot;,\r\n    &quot;Maven.Javagroupwork [compile].executor&quot;: &quot;Run&quot;,\r\n    &quot;Maven.Javagroupwork [install].executor&quot;: &quot;Run&quot;,\r\n    &quot;Maven.Javagroupwork [test].executor&quot;: &quot;Run&quot;,\r\n    &quot;Maven.Javagroupwork [validate].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/igor8/IdeaProjects/Java-group-work/target/mssql-jdbc_auth-12.4.2.x64.dll&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;onboarding.tips.debug.path&quot;: &quot;C:/Users/zion.awino/java testing/Javagroupwork/Java grgouup work/src/main/java/org/example/Main.java&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Libraries&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;run.code.analysis.last.selected.profile&quot;: &quot;pProject Default&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  },\r\n  &quot;keyToStringList&quot;: {\r\n    &quot;ChangesTree.GroupingKeys&quot;: [\r\n      &quot;module&quot;\r\n    ]\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"AppointmentAgenda\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"org.projektarbete.AppointmentAgenda\" />\r\n      <module name=\"Javagroupwork\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"org.projektarbete.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"UserInterfaceTest\" type=\"JUnit\" factoryName=\"JUnit\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Javagroupwork\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"org.projektarbete.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <option name=\"PACKAGE_NAME\" value=\"org.projektarbete\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"org.projektarbete.UserInterfaceTest\" />\r\n      <option name=\"TEST_OBJECT\" value=\"class\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"JetRunConfigurationType\">\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"KotlinStandaloneScriptRunConfigurationType\">\r\n      <option name=\"filePath\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Javagroupwork [install]\" type=\"MavenRunConfiguration\" factoryName=\"Maven\" temporary=\"true\">\r\n      <MavenSettings>\r\n        <option name=\"myGeneralSettings\" />\r\n        <option name=\"myRunnerSettings\" />\r\n        <option name=\"myRunnerParameters\">\r\n          <MavenRunnerParameters>\r\n            <option name=\"cmdOptions\" />\r\n            <option name=\"profiles\">\r\n              <set />\r\n            </option>\r\n            <option name=\"goals\">\r\n              <list>\r\n                <option value=\"install\" />\r\n              </list>\r\n            </option>\r\n            <option name=\"multimoduleDir\" />\r\n            <option name=\"pomFileName\" value=\"pom.xml\" />\r\n            <option name=\"profilesMap\">\r\n              <map />\r\n            </option>\r\n            <option name=\"projectsCmdOptionValues\">\r\n              <list />\r\n            </option>\r\n            <option name=\"resolveToWorkspace\" value=\"false\" />\r\n            <option name=\"workingDirPath\" value=\"$PROJECT_DIR$\" />\r\n          </MavenRunnerParameters>\r\n        </option>\r\n      </MavenSettings>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Application.AppointmentAgenda\" />\r\n      <item itemvalue=\"JUnit.UserInterfaceTest\" />\r\n      <item itemvalue=\"Maven.Javagroupwork [install]\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.AppointmentAgenda\" />\r\n        <item itemvalue=\"JUnit.UserInterfaceTest\" />\r\n        <item itemvalue=\"Maven.Javagroupwork [install]\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-21.0.1-openjdk-21.0.1-f644763e9732-f98dd351\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"b1293931-78f6-405f-9cb5-3f3848f0f5e1\" name=\"Changes\" comment=\"\" />\r\n      <created>1704806365135</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1704806365135</updated>\r\n      <workItem from=\"1704806366219\" duration=\"3000\" />\r\n      <workItem from=\"1705254611535\" duration=\"13245000\" />\r\n      <workItem from=\"1705506929137\" duration=\"4331000\" />\r\n    </task>\r\n    <task id=\"LOCAL−00001\" summary=\"Basic functions have been updated\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705323121724</created>\r\n      <option name=\"number\" value=\"LOCAL−00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00001\" />\r\n      <updated>1705323121724</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00002\" summary=\"Updated the validateDate.now cannoct book meeting in the past.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705324573111</created>\r\n      <option name=\"number\" value=\"LOCAL−00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00002\" />\r\n      <updated>1705324573111</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00003\" summary=\"Updated the validation methods. added comments on changes.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705509290019</created>\r\n      <option name=\"number\" value=\"LOCAL−00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00003\" />\r\n      <updated>1705509290020</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00004\" summary=\"1.1 Design och visning av huvudmeny\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705786348797</created>\r\n      <option name=\"number\" value=\"LOCAL−00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00004\" />\r\n      <updated>1705786348797</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00005\" summary=\"Uppdaterad kod med Maven\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705842847239</created>\r\n      <option name=\"number\" value=\"LOCAL−00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00005\" />\r\n      <updated>1705842847239</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00006\" summary=\"Uppdaterad kod med Maven\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705842977641</created>\r\n      <option name=\"number\" value=\"LOCAL−00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00006\" />\r\n      <updated>1705842977641</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00007\" summary=\"Uppdaterad kod\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1705915871948</created>\r\n      <option name=\"number\" value=\"LOCAL−00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00007\" />\r\n      <updated>1705915871949</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00008\" summary=\"Uppdaterad kod\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1706105912655</created>\r\n      <option name=\"number\" value=\"LOCAL−00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00008\" />\r\n      <updated>1706105912655</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00009\" summary=\"Uppdaterad kod\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1706105948612</created>\r\n      <option name=\"number\" value=\"LOCAL−00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00009\" />\r\n      <updated>1706105948612</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00010\" summary=\"Merge remote-tracking branch 'origin/master'&#10;&#10;# Conflicts:&#10;#&#9;src/main/java/org/projektarbete/Validation.java\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1706106110585</created>\r\n      <option name=\"number\" value=\"LOCAL−00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00010\" />\r\n      <updated>1706106110585</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00011\" summary=\"Merge remote-tracking branch 'origin/master'&#10;&#10;# Conflicts:&#10;#&#9;src/main/java/org/projektarbete/Validation.java\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1706106145116</created>\r\n      <option name=\"number\" value=\"LOCAL−00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00011\" />\r\n      <updated>1706106145116</updated>\r\n    </task>\r\n    <task id=\"LOCAL−00012\" summary=\"Uppdatera med tester\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1706195984425</created>\r\n      <option name=\"number\" value=\"LOCAL−00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL−00012\" />\r\n      <updated>1706195984426</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"13\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Basic functions have been updated\" />\r\n    <MESSAGE value=\"Updated the validateDate.now cannoct book meeting in the past.\" />\r\n    <MESSAGE value=\"Updated the validation methods. added comments on changes.\" />\r\n    <MESSAGE value=\"1.1 Design och visning av huvudmeny\" />\r\n    <MESSAGE value=\"Uppdaterad kod med Maven\" />\r\n    <MESSAGE value=\"Uppdaterad kod\" />\r\n    <MESSAGE value=\"Merge remote-tracking branch 'origin/master'&#10;&#10;# Conflicts:&#10;#&#9;src/main/java/org/projektarbete/Validation.java\" />\r\n    <MESSAGE value=\"Uppdatera med tester\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Uppdatera med tester\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 1970d0b4b484ca93903e5cd7458f86e81785785f)
+++ b/.idea/workspace.xml	(date 1706257113311)
@@ -4,7 +4,14 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="b1293931-78f6-405f-9cb5-3f3848f0f5e1" name="Changes" comment="Uppdatera med tester" />
+    <list default="true" id="b1293931-78f6-405f-9cb5-3f3848f0f5e1" name="Changes" comment="Uppdatera med tester">
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/projektarbete/AppointmentRepository.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/projektarbete/AppointmentRepository.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/projektarbete/DatabaseManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/projektarbete/DatabaseManager.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/projektarbete/UserInterface.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/projektarbete/UserInterface.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/projektarbete/Validation.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/projektarbete/Validation.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/test/java/org/projektarbete/UserInterfaceTest.java" beforeDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -55,49 +62,50 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;Application.Appointment.executor&quot;: &quot;Run&quot;,
-    &quot;Application.AppointmentAgenda.executor&quot;: &quot;Run&quot;,
-    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,
-    &quot;JUnit.AppointmentTest.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.DatabaseManagerTest.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.UserInterfaceTest.executor&quot;: &quot;Run&quot;,
-    &quot;JUnit.ValidationTest.executor&quot;: &quot;Run&quot;,
-    &quot;Maven.Javagroupwork [clean].executor&quot;: &quot;Run&quot;,
-    &quot;Maven.Javagroupwork [compile].executor&quot;: &quot;Run&quot;,
-    &quot;Maven.Javagroupwork [install].executor&quot;: &quot;Run&quot;,
-    &quot;Maven.Javagroupwork [test].executor&quot;: &quot;Run&quot;,
-    &quot;Maven.Javagroupwork [validate].executor&quot;: &quot;Run&quot;,
-    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,
-    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,
-    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,
-    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
-    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,
-    &quot;last_opened_file_path&quot;: &quot;C:/Users/igor8/IdeaProjects/Java-group-work/target/mssql-jdbc_auth-12.4.2.x64.dll&quot;,
-    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
-    &quot;onboarding.tips.debug.path&quot;: &quot;C:/Users/zion.awino/java testing/Javagroupwork/Java grgouup work/src/main/java/org/example/Main.java&quot;,
-    &quot;project.structure.last.edited&quot;: &quot;Libraries&quot;,
-    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,
-    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,
-    &quot;run.code.analysis.last.selected.profile&quot;: &quot;pProject Default&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,
-    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Application.Appointment.executor": "Run",
+    "Application.AppointmentAgenda.executor": "Run",
+    "Downloaded.Files.Path.Enabled": "false",
+    "JUnit.AppointmentTest.executor": "Run",
+    "JUnit.DatabaseManagerTest.executor": "Run",
+    "JUnit.InputReaderTest.executor": "Run",
+    "JUnit.UserInterfaceTest.executor": "Run",
+    "JUnit.ValidationTest.executor": "Run",
+    "Maven.Javagroupwork [clean].executor": "Run",
+    "Maven.Javagroupwork [compile].executor": "Run",
+    "Maven.Javagroupwork [install].executor": "Run",
+    "Maven.Javagroupwork [test].executor": "Run",
+    "Maven.Javagroupwork [validate].executor": "Run",
+    "Repository.Attach.Annotations": "false",
+    "Repository.Attach.JavaDocs": "false",
+    "Repository.Attach.Sources": "false",
+    "RunOnceActivity.OpenProjectViewOnStart": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "SHARE_PROJECT_CONFIGURATION_FILES": "true",
+    "git-widget-placeholder": "master",
+    "kotlin-language-version-configured": "true",
+    "last_opened_file_path": "C:/Users/igor8/IdeaProjects/Java-group-work/target/mssql-jdbc_auth-12.4.2.x64.dll",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
+    "onboarding.tips.debug.path": "C:/Users/zion.awino/java testing/Javagroupwork/Java grgouup work/src/main/java/org/example/Main.java",
+    "project.structure.last.edited": "Libraries",
+    "project.structure.proportion": "0.15",
+    "project.structure.side.proportion": "0.2",
+    "run.code.analysis.last.selected.profile": "pProject Default",
+    "settings.editor.selected.configurable": "preferences.pluginManager",
+    "vue.rearranger.settings.migration": "true"
   },
-  &quot;keyToStringList&quot;: {
-    &quot;ChangesTree.GroupingKeys&quot;: [
-      &quot;module&quot;
+  "keyToStringList": {
+    "ChangesTree.GroupingKeys": [
+      "module"
     ]
   }
-}</component>
-  <component name="RunManager">
+}]]></component>
+  <component name="RunManager" selected="Application.AppointmentAgenda">
     <configuration name="AppointmentAgenda" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
       <option name="MAIN_CLASS_NAME" value="org.projektarbete.AppointmentAgenda" />
       <module name="Javagroupwork" />
@@ -283,7 +291,14 @@
       <option name="presentableId" value="LOCAL−00012" />
       <updated>1706195984426</updated>
     </task>
-    <option name="localTasksCounter" value="13" />
+    <task id="LOCAL−00013" summary="Uppdatera med tester">
+      <option name="closed" value="true" />
+      <created>1706196152899</created>
+      <option name="number" value="LOCAL−00013" />
+      <option name="presentableId" value="LOCAL−00013" />
+      <updated>1706196152899</updated>
+    </task>
+    <option name="localTasksCounter" value="14" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
